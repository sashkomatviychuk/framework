+function ($){"use strict"; // css transition support (shoutout:http://www.modernizr.com/) // ============================================================ function transitionEnd() { var el = document.createElement('bootstrap') var transEndEventNames = { 'WebkitTransition' : 'webkitTransitionEnd' , 'MozTransition' : 'transitionend' , 'OTransition' : 'oTransitionEnd otransitionend' , 'transition' : 'transitionend'}for (var name in transEndEventNames){if (el.style[name] !== undefined) { return { end:transEndEventNames[name]}var $parent = $(selector) if (e) e.preventDefault() if (!$parent.length){$parent = $this.hasclass('alert') ? $this:$this.parent()},Button.DEFAULTS,options) } Button.DEFAULTS ={loadingtext:'loading...'}Button.prototype.setState = function (state){var d = 'disabled' var $el = this.$element var val = $el.is('input') ? 'val':'html' var data = $el.data() state = state + 'Text' if (!data.resetText) $el.data('resetText', $el[val]()) $el[val](data[state] || this.options[state]) // push to event loop to allow forms to submit setTimeout(function () { state == 'loadingText' ? $el.addClass(d).attr(d, d) : $el.removeClass(d).removeAttr(d)}Carousel.DEFAULTS ={interval:5000 , pause: 'hover'}Carousel.prototype.slide = function (type,next){var $active = this.$element.find('.item.active') var $next = next || $active[type]() var iscycling = this.interval var direction = type == 'next' ? 'left':'right' var fallback = type == 'next' ? 'first' : 'last' var that = this this.sliding = true isCycling && this.pause() $next = $next.length ? $next : this.$element.find('.item')[fallback]() var e = $.Event('slide.bs.carousel', { relatedTarget: $next[0], direction: direction},Collapse.DEFAULTS,options) this.transitioning = null if (this.options.parent) this.$parent = $(this.options.parent) if (this.options.toggle) this.toggle() } Collapse.DEFAULTS ={toggle:true}Collapse.prototype.dimension = function (){var haswidth = this.$element.hasclass('width') return haswidth ? 'width':'height'}if (!$.support.transition) return complete.call(this) this.$element [dimension](0) .one($.support.transition.end,$.proxy(complete,this)) .emulateTransitionEnd(350) } Collapse.prototype.toggle = function (){this[this.$element.hasclass('in') ? 'hide':'show']()}// COLLAPSE DATA-API // ================= $(document).on('click.bs.collapse.data-api','[data-toggle=collapse]',function (e){var $this = $(this), href var target = $this.attr('data-target') || e.preventdefault() || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') //strip for ie7 var $target = $(target) var data = $target.data('bs.collapse') var option = data ? 'toggle':$this.data() var parent = $this.attr('data-parent') var $parent = parent && $(parent) if (!data || !data.transitioning) { if ($parent) $parent.find('[data-toggle=collapse][data-parent=' + parent + ']').not($this).addClass('collapsed') $this[$target.hasClass('in') ? 'addClass' : 'removeClass']('collapsed')}Modal.DEFAULTS ={backdrop:true , keyboard: true , show: true}Modal.prototype.toggle = function (){return this[!this.isshown ? 'show':'hide']()}) .emulateTransitionEnd(300) : that.$element.focus().trigger('shown.bs.modal') }) } Modal.prototype.hide = function (e){if (e) e.preventdefault() e = $.event('hide.bs.modal') this.$element.trigger(e) if (!this.isshown || e.isdefaultprevented()) return this.isshown = false this.escape() $(document).off('focusin.bs.modal') this.$element .removeclass('in') .attr('aria-hidden', true) $.support.transition && this.$element.hasclass('fade') ? this.$element .one($.support.transition.end, $.proxy(this.hidemodal, this)) .emulatetransitionend(300):this.hideModal()}Modal.prototype.backdrop = function (callback){var that = this var animate = this.$element.hasclass('fade') ? 'fade':'' if (this.isShown && this.options.backdrop) { var doAnimate = $.support.transition && animate this.$backdrop = $('<div class="modal-backdrop '+ animate + '" />') .appendTo(document.body) this.$element.on('click', $.proxy(function (e) { if (e.target !== e.currentTarget) return this.options.backdrop == 'static' ? this.$element[0].focus.call(this.$element[0]) : this.hide.call(this)},this)) if (doAnimate) this.$backdrop[0].offsetWidth // force reflow this.$backdrop.addClass('in') if (!callback) return doAnimate ? this.$backdrop .one($.support.transition.end,callback) .emulateTransitionEnd(150) : callback() } else if (!this.isShown && this.$backdrop){this.$backdrop.removeclass('in') $.support.transition && this.$element.hasclass('fade')? this.$backdrop .one($.support.transition.end, callback) .emulatetransitionend(150):callback()}// MODAL DATA-API // ============== $(document).on('click.bs.modal.data-api','[data-toggle="modal"]',function (e){var $this = $(this) var href = $this.attr('href') var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) //strip for ie7 var option = $target.data('modal') ? 'toggle':$.extend({ remote:!/#/.test(href) && href}Tooltip.DEFAULTS ={animation:true , placement: 'top' , selector: false , template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>' , trigger: 'hover focus' , title: '' , delay: 0 , html: false , container: false}else if (trigger != 'manual'){var eventin = trigger == 'hover' ? 'mouseenter':'focus' var eventOut = trigger == 'hover' ? 'mouseleave' : 'blur' this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this)) this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))},this.options,{trigger:'manual', selector: ''},this.getDefaults(),this.$element.data(),options) if (options.delay && typeof options.delay == 'number'){options.delay = { show:options.delay , hide: options.delay},self.options.delay.show) } Tooltip.prototype.leave = function (obj){var self = obj instanceof this.constructor ? obj:$(obj.currentTarget)[this.type](this._options).data('bs.' + this.type) clearTimeout(self.timeout) if (!self.options.delay || !self.options.delay.hide) return self.hide() self.hoverState = 'out' self.timeout = setTimeout(function () { if (self.hoverState == 'out') self.hide()},self.options.delay.hide) } Tooltip.prototype.show = function (){var e = $.event('show.bs.'+ this.type) if (this.hascontent() && this.enabled) { this.$element.trigger(e) if (e.isdefaultprevented()) return var $tip = this.tip() this.setcontent() if (this.options.animation) $tip.addclass('fade') var placement = typeof this.options.placement == 'function' ? this.options.placement.call(this, $tip[0], this.$element[0]):this.options.placement var autoToken = /\s?auto?\s?/i var autoPlace = autoToken.test(placement) if (autoPlace) placement = placement.replace(autoToken, '') || 'top' $tip .detach() .css({ top: 0, left: 0, display: 'block'}) .addClass(placement) this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element) var pos = this.getPosition() var actualWidth = $tip[0].offsetWidth var actualHeight = $tip[0].offsetHeight if (autoPlace){var $parent = this.$element.parent() var orgplacement = placement var docscroll = document.documentelement.scrolltop || document.body.scrolltop var parentwidth = this.options.container == 'body' ? window.innerwidth:$parent.outerWidth() var parentHeight = this.options.container == 'body' ? window.innerHeight : $parent.outerHeight() var parentLeft = this.options.container == 'body' ? 0 : $parent.offset().left placement = placement == 'bottom' && pos.top + pos.height + actualHeight - docScroll > parentHeight ? 'top' : placement == 'top' && pos.top - docScroll - actualHeight < 0 ? 'bottom' : placement == 'right' && pos.right + actualWidth > parentWidth ? 'left' : placement == 'left' && pos.left - actualWidth < parentLeft ? 'right' : placement $tip .removeClass(orgPlacement) .addClass(placement)}if (replace) $tip.offset(offset) } Tooltip.prototype.replaceArrow = function(delta,dimension,position){this.arrow().css(position, delta ? (50 * (1 - delta / dimension) + "%"):'')}Tooltip.prototype.setContent = function (){var $tip = this.tip() var title = this.gettitle() $tip.find('.tooltip-inner')[this.options.html ? 'html':'text'](title) $tip.removeClass('fade in top bottom left right')},(typeof el.getBoundingClientRect == 'function') ? el.getBoundingClientRect() :{width:el.offsetWidth , height: el.offsetHeight},this.$element.offset()) } Tooltip.prototype.getCalcuatedOffset = function (placement,pos,actualWidth,actualHeight){return placement == 'bottom' ? { top:pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2}: placement == 'top' ?{top:pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2}: placement == 'left' ?{top:pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth}:{top:pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width}} Tooltip.prototype.getTitle = function (){var title var $e = this.$element var o = this.options title = $e.attr('data-original-title') || (typeof o.title == 'function' ? o.title.call($e[0]):o.title) return title}Tooltip.prototype.toggle = function (e){var self = e ? $(e.currenttarget)[this.type](this._options).data('bs.' + this.type):this self.tip().hasClass('in') ? self.leave(self) : self.enter(self)},$.fn.tooltip.Constructor.DEFAULTS,{placement:'right' , trigger: 'click' , content: '' , template: '<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'}Popover.prototype.setContent = function (){var $tip = this.tip() var title = this.gettitle() var content = this.getcontent() $tip.find('.popover-title')[this.options.html ? 'html':'text'](title) $tip.find('.popover-content')[this.options.html ? 'html' : 'text'](content) $tip.removeClass('fade top bottom left right in') // Hide empty titles // // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do' // this manually by checking the contents. if ($tip.find('.popover-title').html() === '') { $tip.find('.popover-title').hide()}Popover.prototype.getContent = function (){var $e = this.$element var o = this.options return $e.attr('data-content') || (typeof o.content == 'function' ? o.content.call($e[0]):o.content)}}(window.jQuery); +function ($){"use strict"; // scrollspy class definition // ========================== function scrollspy(element, options) { var href var process = $.proxy(this.process, this) this.$element = $(element).is('body') ? $(window):$(element) this.$body = $('body') this.$scrollElement = this.$element.on('scroll.bs.scroll-spy.data-api', process) this.options = $.extend({},ScrollSpy.DEFAULTS,options) this.selector = (this.options.target || ((href = $(element).attr('href')) && href.replace(/.*(?=#[^\s]+$)/,'')) //strip for ie7 || '') + ' .nav li > a' this.offsets = $([]) this.targets = $([]) this.activeTarget = null this.refresh() this.process() } ScrollSpy.DEFAULTS ={offset:10}ScrollSpy.prototype.refresh = function (){var offsetmethod = this.$element[0] == window ? 'offset':'position' this.offsets = $([]) this.targets = $([]) var self = this var $targets = this.$body .find(this.selector) .map(function () { var $el = $(this) var href = $el.data('target') || $el.attr('href') var $href = /^#\w/.test(href) && $(href) return ($href && $href.length && [[ $href[offsetMethod]().top + (!$.isWindow(self.$scrollElement.get(0)) && self.$scrollElement.scrollTop()), href ]]) || null}if ($this.parent('li').hasClass('active')) return var previous = $ul.find('.active:last a')[0] var e = $.Event('show.bs.tab',{relatedtarget:previous}) $this.trigger(e) if (e.isDefaultPrevented()) return var $target = $(selector) this.activate($this.parent('li'),$ul) this.activate($target,$target.parent(),function (){$this.trigger({ type:'shown.bs.tab' , relatedTarget: previous},Affix.DEFAULTS,options) this.$window = $(window) .on('scroll.bs.affix.data-api',$.proxy(this.checkPosition,this)) .on('click.bs.affix.data-api',$.proxy(this.checkPositionWithEventLoop,this)) this.$element = $(element) this.affixed = this.unpin = null this.checkPosition() } Affix.RESET = 'affix affix-top affix-bottom' Affix.DEFAULTS ={offset:0}Affix.prototype.checkPosition = function (){if (!this.$element.is(':visible')) return var scrollheight = $(document).height() var scrolltop = this.$window.scrolltop() var position = this.$element.offset() var offset = this.options.offset var offsettop = offset.top var offsetbottom = offset.bottom if (typeof offset != 'object') offsetbottom = offsettop = offset if (typeof offsettop == 'function') offsettop = offset.top() if (typeof offsetbottom == 'function') offsetbottom = offset.bottom() var affix = this.unpin != null && (scrolltop + this.unpin <= position.top) ? false:offsetBottom != null && (position.top + this.$element.height() >= scrollHeight - offsetBottom) ? 'bottom' : offsetTop != null && (scrollTop <= offsetTop) ? 'top' : false if (this.affixed === affix) return if (this.unpin) this.$element.css('top', '') this.affixed = affix this.unpin = affix == 'bottom' ? position.top - scrollTop : null this.$element.removeClass(Affix.RESET).addClass('affix' + (affix ? '-' + affix : '')) if (affix == 'bottom') { this.$element.offset({ top: document.body.offsetHeight - offsetBottom - this.$element.height()}